\documentclass{book}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{parskip}
\usepackage[margin=1in]{geometry}

\lstset{
    language=Haskell,
    basicstyle=\ttfamily\small,
    keywordstyle=\color{blue},
    commentstyle=\color{green!60!black},
    stringstyle=\color{red},
    showspaces=false,
    showstringspaces=false,
    numbers=left,
    numberstyle=\tiny\color{gray},
    frame=tb,
    framesep=4pt,
    framerule=0.5pt,
    tabsize=4,
    captionpos=b,
    breaklines=true
}

\begin{document}

\chapter{Basic Haskell Syntax}
\label{chap:haskell-syntax}

\section{Introduction to Haskell Syntax}
Haskell's syntax reflects its foundation in mathematical logic and functional programming principles. The language employs a minimalist syntax that emphasizes expressiveness through composition of functions rather than imperative statements. Distinctive features include significant whitespace for block structure, a strong static type system with type inference, and pervasive use of pattern matching. This section systematically explores these elements through concrete examples and detailed explanations.

\section{Module Declaration}
\label{sec:modules}

\begin{lstlisting}
module Main where
\end{lstlisting}

Every Haskell program begins with a module declaration. The \texttt{Main} module serves as the entry point for executable programs, analogous to the \texttt{main} function in C-family languages. The \texttt{where} keyword initiates the module body, containing all subsequent declarations. When no explicit export list is provided (as in this example), all top-level bindings become publicly accessible. For library components, explicit exports clarify the public interface:

\begin{lstlisting}
module Geometry.Sphere 
  ( volume
  , area
  ) where
\end{lstlisting}

Here, only the \texttt{volume} and \texttt{area} functions are exposed to other modules. The module name \texttt{Geometry.Sphere} corresponds to the file path \texttt{Geometry/Sphere.hs}, following Haskell's hierarchical module convention. This encapsulation mechanism enables information hiding and modular program architecture.

\section{Basic Data Types and Variables}
\label{sec:types}

Haskell's type system provides both primitive types and rich abstraction mechanisms. Consider these fundamental type declarations:

\begin{lstlisting}
intVal :: Int
intVal = 42

floatVal :: Float 
floatVal = 3.14159

inferredVal = "Hello Haskell!"
\end{lstlisting}

The \texttt{Int} type represents machine-precision integers (typically 64-bit), while \texttt{Float} denotes single-precision floating-point numbers. Type signatures use the \texttt{::} symbol to associate values with types. The third example demonstrates type inference: the compiler automatically deduces \texttt{inferredVal} has type \texttt{String} (equivalent to \texttt{[Char]}), a list of characters. All bindings are immutable; once defined, their values cannot be altered.

\section{Functions}
\label{sec:functions}

\subsection{Function Definition and Application}
\begin{lstlisting}
add :: Int -> Int -> Int
add x y = x + y
\end{lstlisting}

This function definition contains three essential components:
\begin{enumerate}
\item The \textbf{type signature} \texttt{Int -> Int -> Int} specifies that \texttt{add} accepts two \texttt{Int} arguments and returns an \texttt{Int}. The arrow associates to the right, meaning the type is equivalent to \texttt{Int -> (Int -> Int)}, reflecting Haskell's curried function application.

\item The \textbf{parameter list} \texttt{x y} declares two integer parameters. Unlike imperative languages, parameters are separated by whitespace rather than commas.

\item The \textbf{function body} \texttt{x + y} defines the computation. The equals sign denotes definitional equality rather than assignment.
\end{enumerate}

\subsection{Recursive Definitions with Pattern Matching}
\begin{lstlisting}
factorial :: Integer -> Integer
factorial 0 = 1
factorial n = n * factorial (n - 1)
\end{lstlisting}

The factorial function demonstrates two fundamental Haskell features: recursion and pattern matching. The type \texttt{Integer} represents arbitrary-precision integers, contrasting with fixed-size \texttt{Int}. The definition contains two clauses:

\begin{itemize}
\item The base case \texttt{factorial 0 = 1} matches when the input is exactly zero, terminating the recursion.

\item The recursive case \texttt{factorial n = n * factorial (n - 1)} matches any positive integer, decomposing the problem into smaller subproblems. Parentheses around \texttt{n - 1} are required due to function application having higher precedence than arithmetic operators.
\end{itemize}

\subsection{Conditional Execution with Guards}
\begin{lstlisting}
absolute :: Int -> Int
absolute x
  | x < 0     = -x
  | otherwise = x
\end{lstlisting}

Guards provide a clean syntax for conditional branching. The vertical bar \texttt{|} introduces a Boolean expression, with the corresponding right-hand side executing when the guard evaluates to \texttt{True}. Guards are evaluated top-to-bottom, with \texttt{otherwise} (defined as \texttt{True}) serving as a default case. This example returns the absolute value of integer \texttt{x}, demonstrating how guards can replace nested \texttt{if-then-else} expressions.

\section{Lists and Tuples}
\label{sec:collections}

\subsection{List Construction and Manipulation}
\begin{lstlisting}
numbers :: [Int]
numbers = [1, 2, 3, 4, 5]

evens = [2, 4 .. 20]

myList = 1 : 2 : 3 : []
\end{lstlisting}

Lists are homogeneous sequences with square bracket syntax. The type \texttt{[Int]} denotes a list of integers. Three construction methods are shown:

\begin{itemize}
\item Explicit enumeration: \texttt{[1,2,3,4,5]} creates a list through direct element specification.

\item Arithmetic sequences: The \texttt{..} operator generates elements using step values. \texttt{[2,4..20]} produces even numbers through step inference from the first two elements.

\item Cons operator: The colon \texttt{:} prepends elements to an existing list. The expression \texttt{1:2:3:[]} builds a list equivalent to \texttt{[1,2,3]}.
\end{itemize}

\subsection{List Comprehensions}
\begin{lstlisting}
squares = [x^2 | x <- [1..10]]

pythagoreanTriples = [(a,b,c) | a <- [1..10],
                                b <- [a..10],
                                c <- [b..10],
                                a^2 + b^2 == c^2]
\end{lstlisting}

List comprehensions provide declarative set-builder notation. The first example generates squares of numbers 1 through 10. The vertical bar separates the output expression \texttt{x\^2} from the generator \texttt{x <- [1..10]}.

The Pythagorean triples example demonstrates multiple generators and filters:
\begin{itemize}
\item \texttt{a <- [1..10]} iterates values for side \texttt{a}
\item \texttt{b <- [a..10]} ensures \texttt{b} is at least \texttt{a}
\item \texttt{c <- [b..10]} ensures \texttt{c} is at least \texttt{b}
\item The condition \texttt{a\^2 + b\^2 == c\^2} filters valid right triangles
\end{itemize}

\subsection{Tuple Types}
\begin{lstlisting}
coordinates :: (Double, Double)
coordinates = (3.5, 4.2)

person :: (String, Int, Bool)
person = ("Alice", 30, True)
\end{lstlisting}

Tuples store fixed-size, heterogeneous collections. The type \texttt{(Double, Double)} represents a pair of double-precision numbers, while \texttt{(String, Int, Bool)} contains three elements of different types. Unlike lists, tuples preserve type information for each position, enabling structured data storage without custom types.

\section{Control Structures}
\label{sec:control}

\subsection{Conditional Expressions}
\begin{lstlisting}
signum' :: Int -> Int
signum' x = if x < 0 
            then -1 
            else if x > 0 
                 then 1 
                 else 0
\end{lstlisting}

Haskell's \texttt{if-then-else} construct differs from imperative languages by being an expression rather than a statement. This example returns:
\begin{itemize}
\item -1 for negative inputs
\item 1 for positive inputs
\item 0 for zero
\end{itemize}

Each \texttt{if} must have both \texttt{then} and \texttt{else} branches, as all expressions must evaluate to a value. The indentation aligns alternatives for readability.

\subsection{Pattern Matching with Case}
\begin{lstlisting}
describeList :: [a] -> String
describeList lst = case lst of
  []     -> "Empty"
  [x]    -> "Singleton"
  (_:xs) -> "Multiple elements"
\end{lstlisting}

The \texttt{case} expression performs structural pattern matching on lists:
\begin{itemize}
\item \texttt{[]} matches the empty list
\item \texttt{[x]} matches singleton lists, binding the element to \texttt{x}
\item \texttt{(\_:xs)} matches the cons operator, ignoring the head (\texttt{\_}) and binding the tail to \texttt{xs}
\end{itemize}

This approach elegantly handles different list forms without explicit length checking.

\section{Type Declarations}
\label{sec:types}

\subsection{Algebraic Data Types (ADTs)}
\begin{lstlisting}
data Shape = Circle Float
           | Rectangle Float Float
\end{lstlisting}

ADTs allow creating new types through combinations of sums (alternatives) and products (fields). This definition:
\begin{itemize}
\item Declares a \texttt{Shape} type with two constructors
\item \texttt{Circle} takes a single \texttt{Float} (radius)
\item \texttt{Rectangle} takes two \texttt{Float} values (width and height)
\end{itemize}

Constructors can be used in pattern matching:
\begin{lstlisting}
area :: Shape -> Float
area (Circle r) = pi * r^2
area (Rectangle w h) = w * h
\end{lstlisting}

\subsection{Record Syntax}
\begin{lstlisting}
data Person = Person
  { name :: String
  , age  :: Int
  } deriving (Show)
\end{lstlisting}

Records add named fields to data constructors:
\begin{itemize}
\item \texttt{name} and \texttt{age} are field labels
\item Automatically generates accessor functions: \texttt{name :: Person -> String}
\item \texttt{deriving (Show)} enables string representation
\end{itemize}

Construction and access:
\begin{lstlisting}
alice = Person {name = "Alice", age = 30}
aliceName = name alice  -- "Alice"
\end{lstlisting}

\section{Where vs Let}
\label{sec:where-let}

\subsection{Where Clauses}
\begin{lstlisting}
volume r = (4.0 / 3.0) * pi * r^3
  where pi = 3.141592653589793
\end{lstlisting}

The \texttt{where} clause attaches local definitions to the entire function body:
\begin{itemize}
\item \texttt{pi} is visible throughout the equation
\item Typically used for auxiliary definitions
\item Appears after the main expression
\end{itemize}

\subsection{Let Expressions}
\begin{lstlisting}
surfaceArea r = let pi = 3.141592653589793
                in 4 * pi * r^2
\end{lstlisting}

The \texttt{let} form binds variables locally within an expression:
\begin{itemize}
\item \texttt{pi} is only visible in the \texttt{in} block
\item Can appear in any expression context
\item Allows multiple bindings separated by semicolons
\end{itemize}

\section{Indentation Rules}
\label{sec:indentation}

Haskell uses layout-sensitive syntax for code blocks:
\begin{lstlisting}
main = do
  putStrLn "Enter your name:"
  name <- getLine
  putStrLn ("Hello, " ++ name ++ "!")
\end{lstlisting}

Key rules:
\begin{itemize}
\item All lines in a block must align vertically
\item The \texttt{do} keyword initiates a sequence of IO actions
\item Indentation level determines block membership
\item Tabs are discouraged; use spaces for consistent formatting
\end{itemize}

\section{Complete Example Programs}
\label{sec:examples}

\subsection{Hello World}
\begin{lstlisting}
module Main where

main :: IO ()
main = putStrLn "Hello, World!"
\end{lstlisting}

This canonical example demonstrates:
\begin{itemize}
\item Mandatory \texttt{Main} module for executables
\item \texttt{main} function with \texttt{IO ()} type
\item \texttt{putStrLn} function for string output
\item The unit type \texttt{()} indicating no meaningful return value
\end{itemize}

\subsection{Factorial Calculator}
\begin{lstlisting}
module Main where

factorial :: Integer -> Integer
factorial 0 = 1
factorial n = n * factorial (n - 1)

main :: IO ()
main = do
  putStrLn "Enter a number:"
  input <- getLine
  let n = read input
  putStrLn $ "Factorial: " ++ show (factorial n)
\end{lstlisting}

This interactive program showcases:
\begin{enumerate}
\item Recursive factorial definition with pattern matching
\item \texttt{do} notation for sequencing IO actions
\item \texttt{<-} operator binding input result
\item \texttt{read} converting String to Integer
\item \texttt{show} rendering numerical result as String
\item The \texttt{\$} operator reducing parentheses
\end{enumerate}

\section*{Conclusion}
This chapter provided a comprehensive examination of Haskell's syntax through detailed examples and explanations. Key concepts included module structure, type declarations, function definitions with recursion and pattern matching, list processing, and control structures. These foundations enable the construction of type-safe, expressive programs characteristic of the Haskell paradigm. Subsequent chapters will build upon this base to explore type classes, monadic computation, and advanced functional patterns.

\end{document}
%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
