\documentclass[11pt]{report}
\usepackage[utf8]{inputenc}
\usepackage{a4wide}
\usepackage{epsfig}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{minted}
\usepackage{enumerate}
\usepackage{fancyvrb}
\usepackage{alltt}
\usepackage{fleqn}
\usepackage{epic}
\usepackage{color} 
\usepackage{theorem}
\usepackage{hyperref}
\usepackage{tikz}
\usepackage[all]{hypcap}
\hypersetup{
        colorlinks = true, % comment this to make xdvi work
        linkcolor  = blue,
        citecolor  = red,
        filecolor  = [rgb]{0.1, 0.1, 1.0},
        urlcolor   = [rgb]{0.7, 0.0, 0.7},
        pdfborder  = {0 0 0} 
}

\usepackage{fancyhdr}
\usepackage{lastpage} 

\definecolor{bg}{rgb}{0.9,0.8,0.6}
\definecolor{amber}{rgb}{1.0, 0.75, 0.0}
\definecolor{gold}{rgb}{1.0, 0.843, 0.0}

\renewcommand*{\familydefault}{\sfdefault}

\pagestyle{fancy}

\fancyfoot[C]{--- \thepage/\pageref{LastPage}\ ---}

\fancypagestyle{plain}{%
\fancyhf{}
\fancyfoot[C]{--- \thepage/\pageref{LastPage}\ ---}
\renewcommand{\headrulewidth}{0pt}
}

\renewcommand{\chaptermark}[1]{\markboth{\chaptername \ \thechapter.\ #1}{}}
\renewcommand{\sectionmark}[1]{\markright{\thesection. \ #1}{}}
\fancyhead[R]{\leftmark}
\fancyhead[L]{\rightmark}

\definecolor{amethyst}{rgb}{0.2, 0.4, 0.6}
\definecolor{orange}{rgb}{1, 0.9, 0.0}

{\theorembodyfont{\sf}
\newtheorem{Definition}{Definition}
\newtheorem{Axiom}[Definition]{Axiom}
\newtheorem{Notation}[Definition]{Notation}
\newtheorem{Theorem}[Definition]{Theorem}
}

\newcommand{\blue}[1]{{\color{blue}#1}}


\newcommand{\qed}{\hspace*{\fill} $\Box$
\vspace*{0.2cm}

}

\newcommand{\eod}{\hspace*{\fill} $\diamond$}
\newcommand{\eox}{\hspace*{\fill} $\diamond$}

\newcommand{\dangersign}[1][Danger]{
    \begin{tikzpicture}[scale=0.7]
        % Draw the triangle
        \draw[thick, red, fill=yellow] (0,0) -- (2,3.46) -- (4,0) -- cycle;
        % Add the text (default is "Danger")
        \node at (2,0.8) {\textbf{\textsc{#1}}};
    \end{tikzpicture}
}

\newcommand{\wip}[1][\ \ Work in Progress!]{
    \begin{tikzpicture}[scale=0.7]
        % Draw rectancle
        \draw[thick, blue, fill=orange] (0,3) -- (6.5, 3) -- (6.5,4) -- (0, 4) -- cycle;
        \node at (3,3.5) {\textbf{\textsc{#1}}};
    \end{tikzpicture}
}
\title{\epsfig{file=dhbw-logo.pdf, scale=1.5}\\[0.3cm]  
       \textsl{Haskell}, an Appetizer \\[0.3cm]
      --- Winter 2025 ---}
\author{Prof.~Dr.~Karl Stroetmann}
\date{\today \\[1.5cm]
  \dangersign \wip \dangersign
}


\newcommand{\solution}{\vspace*{0.2cm}

\noindent
\textbf{L\"osung}: }

\newcounter{aufgabe}
\newcommand{\exercise}{\vspace*{0.2cm}
\stepcounter{aufgabe}

\noindent
\textbf{Aufgabe \arabic{aufgabe}}: }

\newcommand{\exerciseStar}{\vspace*{0.2cm}
\stepcounter{aufgabe}

\noindent
\textbf{Aufgabe \arabic{aufgabe}$^*$}: }

\newcommand{\exercises}{\vspace*{0.2cm}
\stepcounter{aufgabe}

\noindent
\textbf{Aufgabe \arabic{aufgabe}$^*$}: }

\newcommand{\example}{\vspace*{0.2cm}

\noindent
\textbf{Beispiel}: \ }

\newcommand{\examples}{\vspace*{0.2cm}

\noindent
\textbf{Beispiele}: \ }
 
\newcommand{\remark}{\vspace*{0.2cm}
\noindent
\textbf{Bemerkung}: }

\newcommand{\lb}{\hspace*{\fill} \linebreak}


\def\pair(#1,#2){\langle #1, #2 \rangle}

\newlength{\mylength}
\setlength{\mathindent}{1.3cm}

\begin{document}
\maketitle

\begin{abstract}
\noindent
This is a very short introduction to the programming language
\href{https://en.wikipedia.org/wiki/Haskell}{\textsl{Haskell}}. 
It is not intended to be a Haskell course.  My intention merely is for the reader to get a taste of what
programming in \textsl{Haskell} feels like.  If I succeed in convincing the reader that \textsl{Haskell} is a
programming language that is both usefull and mind extending, then I consider my job done.
Therefore, this short paper will just present some of the highlights of the programming language
\textsl{Haskell} via examples that I hope the reader finds intriguing enough so that she feels inclined to read
some of the outstanding books introducing Haskell in more depth.  There are three books that I recommend for
those readers who want to understand \textsl{Haskell} in more depth:
\begin{enumerate}
\item \emph{Effective Haskell: Solving Real-World Problems with Strongly Typed Functional Programming} 

      by Rebecca Skinner \cite{skinner:2023}.
\item \emph{Programming in Haskell}, second edition 

      by Graham Hutton \cite{hutton:2016}.
  
\item \emph{Learn You a Haskell for Great Good!},

      by Miran Lipova\v{c}a \cite{lipovaca:2011}.
\end{enumerate}
\end{abstract}

\chapter{Introduction}
In this introduction I will do two things:
\begin{enumerate}
\item First, I discuss those features of Haskell that set Haskell apart from other programming languages.
\item Second, I will present a few short example programs that give a first taste of Haskell.
\end{enumerate}

\section{Why Haskell is Different}
Before we present any details of \textsl{Haskell}, let us categorize this programming language so that we have
an idea about what to expect.  \textsl{Haskell} has the following properties:
\begin{enumerate}
\item \textsl{Haskell} is a \blue{functional programming language}.

  A functional programming language is any programming language that treats functions as
  \blue{first class citiziens}:
  \begin{enumerate}
  \item A function can be given as an argument to another function.
  \item A function can be produce a function as its result.
  \end{enumerate}
  A well known programming language that supports functional programming is \textsl{Python} and there are
  several books discussing functional programming in \textsl{Python}, e.g.~\cite{lott:2022}, \cite{mertz:2015},
  and \cite{reid:2023}.  

\item \textsl{Haskell} is \blue{statically typed}.

  Every variable in Haskell has a fixed type, which can not be changed.  In this respect, \textsl{Haskell} is
  similar to the programming language \textsl{Java}.  However, in contrast to \textsl{Java}, we do not have to
  declare the type of every variable and every function because most of the time the type of a variable can be
  \blue{inferred} by the type system.  Therefore, in Haskell we usually specify only the types of non-trivial
  functions.

  The benefit of this approach is that many type errors will already be caught by the compiler.  This is in
  contrast to programs written in a dynamically typed language like \textsl{Python}, where type errors are only
  discovered at runtime.

\item \textsl{Haskell} is a \blue{pure} functional programming language.

  Once a variable is assigned a value, this value can not be changed.  For example, if we want to sort a list,
  we are not able to change the list data structure.  All we can do is to compute a new list which contains the
  same elements as the old list and which, furthermore, is sorted.

  The property of being a \blue{pure} language sets \textsl{Haskell} apart from most other programming
  languages.  Even the language
  \href{https://en.wikipedia.org/wiki/Scala_(programming_language)}{\textsl{Scala}}, which is designed as a
  modern functional programming language, is not pure.

  What is the big deal about purity?  On one hand, it forces
  the user to program in a declarative style.  Although, in general, nobody likes to be forced to do something,
  there is a huge benefit in pure programming.
  \begin{enumerate}
  \item In a pure programming language, functions will always return the same result when they are called with
    the same arguments.  This property is called \blue{referential transparency}.
    This makes reasoning about code easier, as you can replace a function call with its result without changing
    the behavior of the program.  Therefore the correctness of functions can be verified mathematically.
  \item Since pure functions do not depend on or modify external state, their behavior is entirely predictable.
    The advantage is that testing becomes straightforward because functions can be tested in isolation without
    worrying about interactions with other parts of the system. 
  \item Compilers for pure languages can make aggressive optimizations, such as caching function results
    (\blue{memoization}) or reordering computations, because they know that functions are side-effect-free. 
    The advantage is that programs can often run faster.
  \item Furthermore, \blue{concurrency} becomes much easier to manage when functions do not use global variables and do
    not change their arguments.
  \end{enumerate}
  
\item \textsl{Haskell} is a \blue{compiled} language similar to \textsl{Java} and \texttt{C}, but additionally
  offers an interpreter.  Having an interpreter is beneficial for rapid prototyping.  The property that
  \textsl{Haskell} programs can be compiled ensures that the resulting programs are a lot faster than,
  e.g.~\textsl{Python} programs.
\item \textsl{Haskell} is a \blue{lazy} language.  The programming language \texttt{C} is an \blue{eager}
  language.  If an expression  of the form
  \\[0.2cm]
  \hspace*{1.3cm}
  $f(a_1, \cdots, a_n)$
  \\[0.2cm]
  has to be evaluated, first the subexpressions $a_1$, $\cdots$ $a_n$ are evaluated.  Let us assume that $a_i$
  is evaluated to to value $x_i$.  The, $f(x_1, \cdots, x_n)$ is computed.  This might be very inefficient.
  Consider the following contrived example:

\begin{minted}[ frame         = lines, 
                 framesep      = 0.3cm, 
                 firstnumber   = 1,
                 bgcolor       = bg,
                 numbers       = left,
                 numbersep     = -0.2cm,
                 xleftmargin   = 0.8cm,
                 xrightmargin  = 0.8cm,
               ]{C}
  int f(int x, int y) {
      if (x == 2) {
          return 42;
      }
      return 2 * y;
  }
\end{minted}
Let us assume that the expression
\\[0.2cm]
\hspace*{1.3cm}
\texttt{f(h(0), g(1))}
\\[0.2cm]
needs to be evaluated and that the computation of \texttt{g(1)} is very expensive.  In a
\texttt{C}-program, the expressions and \texttt{h(0)} and \texttt{g(1)} will be both evaluated.  If it turns out that
\texttt{h(0)} is \texttt{2}, then the evaluation of \texttt{g(1)} is not really necessary.  Nevertheless, in \texttt{C} this
evaluation takes place because \texttt{C} has an \blue{eager} evaluation strategy.  In contrast, an equivalent
\textsl{Haskell} would not evaluate the expression \texttt{h(0)} and hence would be much more efficient.

\item \textsl{Haskell} is difficult to learn.

  You might ask yourself why \textsl{Haskell} hasn't been adopted more widely.  After all, it has all these
  cool features mentioned above.  The reason is that learning \textsl{Haskell} is a lot more difficult then
  learning a language like \textsl{Python} or \textsl{Java}.  There are two reasons for this:
  \begin{enumerate}[(a)]
  \item First, \textsl{Haskell} differs a lot from those languages that most people know.
  \item In order to be very concise, the syntax of \textsl{Haskell} is quite different from the syntax of
        established programming languages.
  \item \textsl{Haskell} requires the programmer to think on a very high level of abstraction.
        Many students find this difficult.
  \item Lastly, and most importantly, \textsl{Haskell} supports the use of a number of concepts
        like, e.g.~\href{https://en.wikipedia.org/wiki/Functor}{functors} and
        \href{https://en.wikipedia.org/wiki/Monad_(category_theory)}{monads} from 
        \href{https://en.wikipedia.org/wiki/Category_theory}{category theory}. 
        It takes both time and mathematical maturity to really understand these concepts.

        If you really want to understand the depth of \textsl{Haskell}, you have to dive into those topics.
        
  \item Fortunately, it is possible to become productive in \textsl{Haskell} without understanding category
        theory.  Therefore, this lecture will focuss on those parts of \textsl{Haskell} that are more easily
        accessible. 
  \end{enumerate}
\end{enumerate}

\section{A First Taste of Haskell}
\begin{figure}[!ht]
\centering
\begin{minted}[ frame         = lines, 
                 framesep      = 0.3cm, 
                 firstnumber   = 1,
                 bgcolor       = bg,
                 numbers       = left,
                 numbersep     = -0.2cm,
                 xleftmargin   = 0.8cm,
                 xrightmargin  = 0.8cm,
               ]{haskell}
    primes :: [Integer]
    primes = sieve [2..]
    
    sieve :: [Integer] -> [Integer]
    sieve (p:ns) = p : sieve [n | n <- ns, mod n p /= 0]
\end{minted}
\vspace*{-0.3cm}
\caption{}
\label{fig:}
\end{figure}


\bibliographystyle{alpha}
\bibliography{cs}



\end{document}




%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
